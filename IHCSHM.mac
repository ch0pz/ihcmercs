|- IHCSHM.mac - By DrWhompd  & Morisato & Ihc385
|- Automatic Shaman Bot
|- Version 1.0
|- Updated: 1/14/2020
|- Credit: Toots, Noobhax0r, Maskoi, Ctaylor, Treehuggindruid. A lot of ideas were borrowed and modified from their macros
#Chat group
#Chat tell
#Chat raid
#turbo 80
#include IHCMercs\ihcsubs.inc
#include IHCMercs\ihcshmutil.inc
#include IHCMercs\ihcevents.inc
#warning
#bind SetVarInt	/setvarint
#bind CmdList        /ihchelp
#bind BNDSingleCure	/curesingle
#Event NotOnTarget	"#*#You cannot see your target#*#"
#Event NotOnTarget	"#*#Your target is too far away#*#"
#Event WornOff      "Your #1# spell has worn off of #*#."
#Event GroupChange	"#*#has joined the group#*#"

Sub Main
	/delay ${Math.Rand[10]}
	/doevents flush
	/declare MacroName       	string outer IHCSHM**ALPHA**
	/declare MacroPath       	string outer IHCMercs\IHCSHM
	/declare IHCVersion       	string outer 1.2 
	/declare IniFileName     	string outer ${MacroPath}_${EverQuest.Server}_${Me.CleanName}.ini

	/call ShmSetup
	/call VarSetup
	/call ClassAliasSetup

	/call CheckSpells
	/call SetControlToon
	/call LoadSpellBar
    /call Icesetup
	/if (${UseMelee}) /djoin ihcdps
	/pet hold on
|-Cursor ID
	/if (${Cursor.ID}) {
		/echo Sending Item on Cursor to Bag
		/autoinventory
	}
	/call WelcomeMsg
	/if (${assistid}==${Me.ID}) {
		/echo \aw I am Main Assist
	} else {
		/echo \aw Assisting \ay >> \ag ${assistname} \ay << \aw at \ag ${AutoAssistAt}%
	}
	
	/if (${UseZoneLogic}) {
		/call ZoneEventChk
	}
 :mainloop
	/call Wintitle
	/if (${changetoini}==1) /call INIChanges
	/if (${Me.Zoning}) {
		/call Zoning
	}
	/if (${Me.Hovering}) /call DeathSub
	/if (${Cursor.ID}) /call BagModRods
    /call IceCheck
	/call TankChangeCheck
	/if (!${Me.Casting.ID} && (${Me.XTarget[1].ID} || !${Me.Invis}) && ((${DoAACanni} && ${Me.PctMana}<${AACanniManaPct}) || (${DoSpellCanni} && ${Me.PctMana}<${CanniManaPct}))) /call HealthToMana
	/if (${DynamicHealing}) /call ConfigHeal
    
    |- The end of the HealGroup will call a DPS routine if healing is not needing. DPS routine is Combatdps
	/if (!${Me.Casting.ID} && (${Me.XTarget[1].ID} || !${Me.Invis})) /call HealGroup
    
    |- Rez Sub placeholder
    /if ((${AutoRez}==1) && (!${Me.Moving}) && (!${Me.Invis})) /call RezCheck
    
	/if ((${Me.PctMana}>=30) && (!${Me.Casting.ID}) && (!${Me.XTarget[1].ID}) && (!${Me.Invis}) && !${MoveTo.Moving} && !${AdvPath.Following} && ${Stick.Status.Equal[OFF]} && ${DoBuffs}) /call BuffCheck
	/if ((${Me.PctMana}>=30) && (!${Me.Casting.ID}) && (!${Me.XTarget[1].ID}) && (!${Me.Invis}) && !${MoveTo.Moving} && !${AdvPath.Following} && ${Stick.Status.Equal[OFF]} && ${groupbufftimer}==0 && ${DoBuffs}) /call BuffGroup
	/if (${Spawn[=${FollowToonName}].ID} && !${MoveTo.Moving} && ${Stick.Status.Equal[OFF]} && (!${Me.Casting.ID}) && (!${Me.XTarget[1].ID} || ${Spawn[id ${assistid}].Distance}>${AssistRange} || (!${Spawn[id ${assistid}].LineOfSight}))) /call FollowToon
	/if (${Spawn[=${FollowToonName}].ID} && (${Me.Casting.ID} || ${Me.XTarget[1].ID}) && ${AdvPath.Following}) /squelch /afollow off
	/if (!${Me.XTarget[1].ID}&& !${KillTargetID}) /call AutoCampCheck
	/if (${UseModRods}) /call ClickModRoD
	/if (${DoMed} && ${spellrememtimer}==0) /call AutoMed
	/if (${UseZoneLogic} && ${EventSetupFlag}) {
		/call EventLogic${EventSetupFlag}
	}
	/if (((!${Spawn[targetable id ${KillTargetID}].ID}) || ${Spawn[corpse id ${KillTargetID}].ID}) && ${KillTargetID}!=0) {
		/varset KillTargetID 0
		/varset SpawnSearchType npc
		/varset autotargetid 0
	}
	/if (${Me.Pet.Combat} && !${Ok2Assist}) {
		/pet back off
	}
	/doevents
	/goto :mainloop
/return
|----------------------------------------------------------------------------
|- SUB: HealthToMana
|---------------------------------------------------------------------------- 
Sub HealthToMana
	/if (${DoAACanni} && ${Me.PctMana}<${AACanniManaPct} && ${Me.PctHPs}>=${AACanniMinHP} && ${Me.AltAbilityReady[Cannibalization]}) {
		/call AANow ${Me.AltAbility[Cannibalization].ID} ${Me.ID}
		/delay 20 !${Me.Casting.ID}
	} else /if (${DoSpellCanni} && ${Me.PctMana}<${CanniManaPct} && ${Me.PctHPs}>=${CanniMinHP} && ${Me.SpellReady[${CanniSpell}]}) {
		/call SpellQueue "${CanniSpell}" ${Me.ID}
		/delay ${Math.Calc[(${Spell[${CanniSpell}].MyCastTime}/100)+5].Int} !${Me.Casting.ID}
	}
/return
|----------------------------------------------------------------------------
|- SUB: HealGroup
|---------------------------------------------------------------------------- 
Sub HealGroup
	/declare WaitOnHeals int local 0
	/if (${DoHeals}) {
		/declare petworsthurtid		int local 0
		/declare petworsthp 		int local 100
		/declare worsthp 			int local 100
		/declare worsthurtid		int local 0
		/declare worsthurtname		string local NULL
		/declare gmember			int local 0
		/declare HurtMember     	int local 0
		/varset GrPCond .
|-		/if (${Stick.Status.Equal[ON]}) {
|-			/stick pause
|-			/varset WasStickOn 1
|-		}
		/if (${Me.PctHPs}<=${GroupHealPoint}) {
		/varcalc HurtMember ${HurtMember}+1
		/varset worsthurtid ${Me.ID}
		/varset worsthurtname ${Me.Name}
		/varset worsthp ${Me.PctHPs}
		}
		/for gmember 1 to ${Group}
			/if (${Group.Member[${gmember}].Distance}<=185 && ${Group.Member[${gmember}].PctHPs}<100 && !${Group.Member[${gmember}].Hovering} && ${Group.Member[${gmember}].Type.NotEqual[Corpse]}) {
                |- Calculate number of hurt group members
				/if ((${Group.Member[${gmember}].Distance}<100) && (${Group.Member[${gmember}].PctHPs}<${GroupHealPoint}) && (${Group.Member[${gmember}].PctHPs}>=1)) {
                    /varcalc HurtMember ${HurtMember}+1
                }
                
                |- Determine who is the worst hurt group member
				/if (${Group.Member[${gmember}].PctHPs}<=${worsthp} && ((${Me.XTarget[1].PctHPs}<=99) || ${Group.Member[${gmember}].Distance}<50)) {
					/varset worsthurtid ${Group.Member[${gmember}].ID}
					/varset worsthurtname ${Group.Member[${gmember}].Name}
					/varset worsthp ${Group.Member[${gmember}].PctHPs}
					/varset GrPCond .
				}
			}
			/if (${Group.Member[${gmember}].Pet.ID}) {
				/if (${Group.Member[${gmember}].Pet.Distance}<=185 && (${Group.Member[${gmember}].Pet.PctHPs}<=${worsthp}) && (${Group.Member[${gmember}].Pet.PctHPs}<=${PetHealPoint}) && ${PetHealPoint}>0 && (${worsthp}>${GroupHealPoint})) {         
					/varset worsthurtid ${Group.Member[${gmember}].Pet.ID}
					/varset worsthurtname ${Group.Member[${gmember}].Name}
					/varset petworsthp ${Group.Member[${gmember}].Pet.PctHPs}
					/varset GrPCond .Pet.
				}
			}
			/if (${DanNet.Peers.Find[${Group.Member[${gmember}].Name.Lower}]} && ${CureCheckTimer}==0) {
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${gmember}].Name.Lower} "Me.TotalCounters" "tmpcureflag" "int"
				/if (${tmpcureflag}) {
					/varcalc CureMemberCount ${CureMemberCount}+1
					/if (${CureMemberID}!=${assistid}) {
						/varset CureMemberID ${Group.Member[${gmember}].ID}
					}
				}
			}
		/next gmember

		/if (${CureCheckTimer}==0) /varset CureCheckTimer 3s
        
		/if (!${Me.Buff[Roar of the Lion].ID} && !${Me.Buff[Dissident Roar].ID} && ${Me.CurrentMana}>${Spell[${DichoSpell}].Mana} && !${Me.Casting.ID} && ${Me.SpellReady[${DichoSpell}]} && ${UseRoar} && (${Group.Member[${assistname}]${TnKCond}PctHPs}>${BigHealPoint}) && ${Me.XTarget[1].ID} && (${Group.Member[${assistname}]${TnKCond}Distance}<=159)) {
			/call SpellQueue "${DichoSpell}" ${assistid}
			/delay ${Math.Calc[(${Spell[${DichoSpell}].MyCastTime}/100)+5].Int} !${Me.Casting.ID}
		} else /if (!${Me.Song[${GroupRenewalHoT}].ID} && !${Me.Buff[${GroupRenewalHoT}].ID} && (${Group.Member[${assistname}]${TnKCond}Distance}<=159) && ${Me.XTarget[1].ID} && (${Group.Member[${assistname}]${TnKCond}PctHPs}>${BigHealPoint}) && !${Me.Casting.ID}) {
            /if (${Spell[${GroupRenewalHoT}].Level} < 70 ) {
                |- We're casting a low level HoT that is single target. This means we'll
                |- need a DanNet query to see if it's on them.
                /if ( ${DanNet.Peers.Find[${Group.Member[${assistname}].Name.Lower}]} ) {
                    |- Check for the heal over time in the songs -- we won't worry about the stacking check -- NOTE: This could be a future corner case.
                    /call Gquery ${EverQuest.Server.Lower}_${Group.Member[${assistname}].Name.Lower} "Me.Song[${GroupRenewalHoT}].ID" "tmpbuffid" "int
                    /if (!${tmpbuffid}) {
                        |- They don't have the HoT effect so we're going to need to cast it
                        /call SpellQueue "${GroupRenewalHoT}" ${assistid}
                        /delay ${Math.Calc[(${Spell[${GroupRenewalHoT}].MyCastTime}/100)+5].Int} !${Me.Casting.ID}
                    }
                }
            } else {
                |- We're casting the Group HoTs at this point so it's not an issue. The 
                |- original self-checks will work 
                /call SpellQueue "${GroupRenewalHoT}" ${assistid}
                /delay ${Math.Calc[(${Spell[${GroupRenewalHoT}].MyCastTime}/100)+5].Int} !${Me.Casting.ID}
            }
		}
        
		/if (${FindItem[=${EpicSpiritStaff}].ID} && ${Me.ItemReady[=${EpicSpiritStaff}]} && ${Me.XTarget[1].ID} && !${Me.Casting.ID} && ${Group.Member[${assistname}]${TnKCond}Type.NotEqual[Corpse]}) {
			/docommand /dgt \ag ITEM CAST \ar =>> \ay ${EpicSpiritStaff} \ar <<=
			/useitem "${EpicSpiritStaff}"
			/delay 10
		}
        
		|-Group Healing
		/if (${HurtMember}>=${GroupHealCount} && ${Me.AltAbilityReady[Soothsayer's Intervention]} && ${Group} && ${worsthp}<65 && (${worsthp}<=${GroupHealPoint})) {
			/call AANow ${Me.AltAbility[Soothsayer's Intervention].ID} ${Me.ID}
			/varset WaitOnHeals 1
			/delay 10
		} else /if (${HurtMember}>=${GroupHealCount} && ${Me.SpellReady[${InterventionHeal}]} && ${Group} && ${worsthp}<65 && (${worsthp}<=${GroupHealPoint})) {
			/call SpellQueue "${InterventionHeal}" ${Me.ID}
			/varset WaitOnHeals 1
			/delay 10
		} else /if (${HurtMember}>=${GroupHealCount} && ${Me.SpellReady[${RecourseHeal}]}) {
			/call SpellQueue "${RecourseHeal}" ${Me.ID}
			/varset WaitOnHeals 1
			/delay 10
		} else /if (${Me.PctHPs}<=${GroupHealPoint}) {
			/call HealQueue ${Me.ID}
			/varset WaitOnHeals 1
		} else /if ((${Group.Member[${assistname}]${TnKCond}Distance}<=185) && ${Group.Member[${assistname}]${TnKCond}Type.NotEqual[Corpse]} && (${Group.Member[${assistname}]${TnKCond}PctHPs}<=${TankHealPoint}) && ${Group.Member[${assistname}]${TnKCond}PctHPs}>=1) {
			/call HealQueue ${assistid}
		} else /if ((${Group.Member[${worsthurtname}]${GrPCond}Distance}<=185) && (${worsthp}<=${GroupHealPoint} || ${petworsthp}<=${GroupHealPoint}) && ${Group.Member[${worsthurtname}]${GrPCond}PctHPs}>=1) {
			/call HealQueue ${worsthurtid}
		} else /if ((${Me.Poisoned.ID} || ${Me.Diseased.ID} || ${Me.Cursed.ID}) && (${Me.AltAbilityReady[Radiant Cure]} || ${Me.AltAbilityReady[Purified Spirits]}) && !${Me.Casting.ID} && ${DoCures} && ${CureTimer}==0) {
			/call GroupCure ${Me.ID}
		} else /if (${Me.AltAbilityReady[Radiant Cure]} && !${Me.Casting.ID} && ${CureMemberCount}>1 && ${CureTimer}==0 && ${DoCures}) {
			/call GroupCure ${Target.ID}
		} else /if ((${Me.AltAbilityReady[Radiant Cure]} || ${Me.SpellReady[${CureSpell}]}) && !${Me.Casting.ID} && ${CureMemberID} && ${CureTimer}==0 && ${DoCures}) {
			/call SingleCure ${CureMemberID}
		}
        
		/varset GrPCond .

        /if (${Defined[tmpcureflag]}) {
            /deletevar tmpcureflag
        }
	}
    
	/if (!${WaitOnHeals}) {
		/if ((${Me.XTarget[1].ID} || (${Group.MainAssist.ID} && ${Group.MainAssist.ID}!=${Me.ID} && ${Target.ID}!=${${assisttargetid}}) || ${SpawnCount[npc radius ${AssistRange} zradius 15 targetable playerstate 4]} || ${FollowMarkTarget}) && !${BackOffFlag} && ${DoAutoTarget}) /call FindTarget
		/if ((${Me.XTarget[1].ID} || ${KillTargetID}) && ${Target.PctHPs}<=${AutoAssistAt} && ${Target.ID}==${autotargetid} && ${Target.Distance}<${AssistRange} && (!${Target.Mezzed.ID} || ${AllowMezBreak}) && !${BackOffFlag} && ${DoAutoEngage}) /call EngageTarget
		/if (${Me.XTarget[1].ID} && (${DoMalo} || ${DoAEMalo} || ${DoSlow} || ${DoAESlow}) && !${BackOffFlag} && ${Target.ID}==${autotargetid} && ${Target.Distance}<${AssistRange} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight} && ${Target.Type.Equal[NPC]} && ${Target.PctHPs}<=${AutoDebuffAt} && ${Ok2Assist}) /call DebuffMobs
		/if ((${Me.XTarget[1].ID} || ${KillTargetID}) && ${Target.ID}==${autotargetid} && ${Target.Distance}<${AssistRange} && (!${Target.Mezzed.ID} || ${AllowMezBreak}) && !${BackOffFlag}) /call AANDisc
		/if ((${Me.XTarget[1].ID} || ${KillTargetID}) && ${Target.PctHPs}<=${AutoAssistAt} && ${Target.ID}==${autotargetid} && ${Target.Distance}<${AssistRange} && ${Ok2Assist} && (!${Target.Mezzed.ID} || ${AllowMezBreak}) && !${BackOffFlag}) /call Combatdps
	}
    
	/doevents
/return
|----------------------------------------------------------------------------
|- SUB: SingleCure
|----------------------------------------------------------------------------
Sub SingleCure(int cureid)
	/varset CureTimer 10s
	/if (${Me.AltAbilityReady[Radiant Cure]}) {
		/call AANow ${Me.AltAbility[Radiant Cure].ID} ${cureid}
	} else /if (${Me.SpellReady[${CureSpell}]}) {
		/call SpellQueue "${CureSpell}" ${cureid}
	}
	/varset CureMemberCount 0
	/varset CureMemberID 0
/return
|----------------------------------------------------------------------------
|- SUB: GroupCure
|----------------------------------------------------------------------------
Sub GroupCure(int cureid)
	/varset CureTimer 10s
	/if (${Me.AltAbilityReady[Purified Spirits]} && ${Me.ID}==${cureid}) {
		/call AANow ${Me.AltAbility[Purified Spirits].ID} ${cureid}
	} else /if (${Me.AltAbilityReady[Radiant Cure]}) {
		/call AANow ${Me.AltAbility[Radiant Cure].ID} ${cureid}
	}
	/varset CureMemberCount 0
	/varset CureMemberID 0
/return
|----------------------------------------------------------------------------
|- SUB: Group HealQueue - New logic
|---------------------------------------------------------------------------- 
Sub HealQueue(int nextid)
	/declare nexthealspell		string local NULL
	/varset GrPCond .
	/if (${Spawn[${nextid}].Type.Equal[Pet]}) {
		/declare groupmembertoheal	string local ${Spawn[${nextid}].Master.Name}
		/varset GrPCond .Pet.
	} else {
		/declare groupmembertoheal	string local ${Spawn[${nextid}].Name}
		/varset GrPCond .
	}
|-Check to see if we can heal
	/if (${Group.Member[${groupmembertoheal}]${GrPCond}FeetWet}!=${Me.FeetWet}) /return
	/if (${Group.Member[${groupmembertoheal}]${GrPCond}Hovering} || ${Group.Member[${groupmembertoheal}]${GrPCond}Type.Equal[Corpse]}) /return

|-Shaman AAs before heals
	/if (${nextid}==${assistid} && ${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}>${BigHealPoint} && (${Me.XTarget}>3 || ${Spawn[id ${Me.XTarget[1].ID} radius 100].Named})) {
		/if (${Me.AltAbilityReady[Spirit Guardian]}) /call AANow ${Me.AltAbility[Spirit Guardian].ID} ${assistid}
	}
	
	/if ((${Group.Member[${assistname}]${TnKCond}Distance}<=159) && ${Me.SpellReady[${TwinHealNuke}]} && ${Group.Member[${assistname}]${TnKCond}PctHPs}>${BigHealPoint} && ${Me.PctMana}>=${Manatonuke} && ${Me.XTarget[1].PctHPs}<98 && ${Me.XTarget[1].ID}) {
			/call SpellQueue "${TwinHealNuke}" ${assistid}
			/delay 10 !${Me.Casting.ID}
	}
|-Determine which heal to use
	/if (${ChestCombatCast} && ${FindItem[${ChestItemName}].ID} && ${FindItem[${ChestItemName}].Timer}==0 && ${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=40 && ${Group.Member[${groupmembertoheal}]${GrPCond}Type.NotEqual[Pet]}) {
		/call ItemNow "${ChestItemName}"
	} else /if ((${Me.SpellReady[${RecklessHeal1}]}) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${BigHealPoint}) && (${nextid}==${assistid}) && ${Me.CurrentMana}>${Spell[${RecklessHeal1}].Mana}) {
		/varset nexthealspell ${RecklessHeal1}
	} else /if ((${Me.SpellReady[${RecklessHeal2}]}) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${BigHealPoint}) && (${nextid}==${assistid}) && ${Me.CurrentMana}>${Spell[${RecklessHeal2}].Mana}) {
		/varset nexthealspell ${RecklessHeal2}
	} else /if ((${Me.SpellReady[${RecklessHeal3}]}) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${BigHealPoint}) && (${nextid}==${assistid}) && ${Me.CurrentMana}>${Spell[${RecklessHeal3}].Mana}) {
		/varset nexthealspell ${RecklessHeal3}
	} else /if ((${Me.AltAbilityReady[Soothsayer's Intervention]}) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<65) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${GroupHealPoint})) {
		/call AANow ${Me.AltAbility[Soothsayer's Intervention].ID} ${Me.ID}
		/delay 10
	} else /if ((${Me.SpellReady[${InterventionHeal}]}) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<65) && ${Me.CurrentMana}>${Spell[${InterventionHeal}].Mana} && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${GroupHealPoint})) {
		/varset nexthealspell ${InterventionHeal}
	} else /if ( ${Me.SpellReady[${RecklessHeal2}]} && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${GroupHealPoint}) && ${Me.CurrentMana}>${Spell[${RecklessHeal2}].Mana} ) {
        /varset nexthealspell ${RecklessHeal2}
    } else /if ((${Me.SpellReady[${RecourseHeal}]}) && (${Group.Member[${groupmembertoheal}]${GrPCond}PctHPs}<=${GroupHealPoint}) && ${Me.CurrentMana}>${Spell[${RecourseHeal}].Mana}) {
		/varset nexthealspell ${RecourseHeal}
	} else /if ((${Me.SpellReady[${AESpiritualHeal}]}) && ${Me.CurrentMana}>${Spell[${AESpiritualHeal}].Mana} && ${Group.Member[${groupmembertoheal}]${GrPCond}LineOfSight}) {
		/varset nexthealspell ${AESpiritualHeal}
	}

	/if (${Bool[${nexthealspell}]}) {
		|------------Broadcast Spell--------------------
		/if (${Me.Sitting}) /stand
		/if (${Window[SpellBookWnd]}) /book
		/if (${Target.ID}!=${nextid}) {
			/if (${Me.Combat}) /squelch /attack off
			/target id ${nextid}
			/delay 5 ${Target.ID}==${nextid}
		}
		/if (!${Me.Casting.ID} && ${Me.SpellReady[${nexthealspell}]}) {
			/cast "${nexthealspell}"
			/if (${acverbose}!=0 && ${Me.Casting.ID}==${Spell[${nexthealspell}].ID}) {
				/if (${Target.PctHPs}>=85) {
					/docommand /dgt \ag ${nexthealspell} \ar =>> \ay ${groupmembertoheal} \ar <<= \ag ${Target.PctHPs}% HP \ax
				} else /if (${Target.PctHPs}>=50) {
					/docommand /dgt \ag ${nexthealspell} \ar =>> \ay ${groupmembertoheal} \ar <<= \ay ${Target.PctHPs}% HP \ax
				} else /if (${Target.PctHPs}<50) {
					/docommand /dgt \ag ${nexthealspell} \ar =>> \ay ${groupmembertoheal} \ar <<= \ar ${Target.PctHPs}% HP \ax
				}
			}
			/varset groupbufftimer 1m
			/delay 10 ${Window[CastingWindow].Open}
			/delay ${Math.Calc[(${Spell[${nexthealspell}].MyCastTime}/100)+5].Int} !${Me.Casting.ID}
		}
	}
	/varset GrPCond .
/return
|----------------------------------------------------------------------------
|- SUB: DebuffMobs
|---------------------------------------------------------------------------- 
Sub DebuffMobs
	/if (${Me.GroupAssistTarget.ID} && ${Me.GroupAssistTarget.ID}!=${Target.ID}) {
		/call FindTarget
	}
	/if (${Stick.Status.Equal[ON]}) {
		/stick pause
		/varset WasStickOn 1
	}
    
    
	/if ( ${DoAEMalo} && ${Bool[${AEMaloSpell}]} ) {
        |- Make sure we're ready to cast AE Malo
        /if ( (!${Target.Maloed.ID}) && !${Me.Casting.ID} && !${Me.Moving} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight} ) {
            /if ( ${ReadyToCast}==0 && ${Me.Level} >= 95 && ${Me.AltAbilityReady[Wind of Malaise]} ) {
                |- AE Malo AA only >= LVL 95
                /alt act ${Me.AltAbility[Wind of Malaise].ID}
                /delay 10 !${Me.AltAbilityReady[Wind of Malaise]}
                /varset ReadyToCast ${Math.Calc[(${Me.AltAbility[Wind of Malaise].Spell.MyCastTime}/100)+3]}
            } else {
                |- Make sure our AEMalo Spell is ready to cast
                /if (${Me.SpellReady[${AEMaloSpell}]}) {
                    |- Use the AEMalo Spell
                    /call CastSpell "${AEMaloSpell}" ${autotargetid}
                }
            }
        }
	} 
    
    /if ( ${DoMalo} && ${Bool[${MaloSpell}]} ) {
		|- Make sure we're ready to cast Malo
        /if ((!${Target.Maloed.ID}) && !${Me.Casting.ID} && !${Me.Moving} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight} ) {
            /if ( ${ReadyToCast}==0 && ${Me.AltAbilityReady[Malaise]} && ${Me.Level} >= 95 ) {
                |- Malo AA only >= LVL 75
                /alt act ${Me.AltAbility[Malaise].ID}
                /delay 10 !${Me.AltAbilityReady[Malaise]}
                /varset ReadyToCast ${Math.Calc[(${Me.AltAbility[Malaise].Spell.MyCastTime}/100)+3]}
            } else {
                |- Make sure our Malo Spell is ready to cast
                /if (${Me.SpellReady[${MaloSpell}]}) {
                    |- Use the Malo Spell
                    /call CastSpell "${MaloSpell}" ${autotargetid}
                }
            }
            
        }
	}
    
	/if (${DoAESlow} && ${Bool[${AESlowSpell}]} ) {
        |- Make sure we're ready to cast AE Slow
        /if ( !${Me.Casting.ID} && !${Me.Moving} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight} && (!${Target.Slowed.ID}) ) {
            |- AE Slow AA only >= LVL 80
            /if ( ${ReadyToCast}==0 && ${Me.AltAbilityReady[Turgur's Virulent Swarm]} && ${Me.Level} >= 80 ) {
                /alt act ${Me.AltAbility[Turgur's Virulent Swarm].ID}
                /delay 25 !${Me.AltAbilityReady[Turgur's Virulent Swarm]}
                /varset ReadyToCast ${Math.Calc[(${Me.AltAbility[Turgur's Virulent Swarm].Spell.MyCastTime}/100)+3]}
            } else {
                |- Is AEslow spell ready?
                /if (${Me.SpellReady[${AESlowSpell}]}) {
                    |- Cast AEslow spell
                    /call CastSpell "${AESlowSpell}" ${autotargetid}
                }
            }
        }
	} 
    
    /if (${DoSlow} && ${Bool[${SlowSpell}]} ) {
        /if ( (!${Target.Slowed.ID}) && !${Me.Casting.ID} && !${Me.Moving} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight}) {
            |- Make sure we're ready to cast AA Slow
            /if ( ${ReadyToCast}==0 && ${Me.Level} >=78 && ${Me.AltAbilityReady[Turgur's Swarm]} ) {
                |- Slow AA only >= 78
                /alt act ${Me.AltAbility[Turgur's Swarm].ID}
                /delay 10 !${Me.AltAbilityReady[Turgur's Swarm]}
                /varset ReadyToCast ${Math.Calc[(${Me.AltAbility[Turgur's Swarm].Spell.MyCastTime}/100)+3]}
            } else {
                |- Is slow spell ready?
                /if (${Me.SpellReady[${SlowSpell}]}) {
                    |- Cast slow spell
                    /call CastSpell "${SlowSpell}" ${autotargetid} dbf
                }
            }
        }
	}
    
	/if (${WasStickOn}) {
		/stick unpause
		/varset WasStickOn 0
	}
|-	/varset groupbufftimer 1m
/return
|----------------------------------------------------------------------------
|- SUB: AANDisc
|---------------------------------------------------------------------------- 
Sub AANDisc
	/doevents
	/if (${FindItem[=${EpicSpiritStaff}].ID} && ${Me.ItemReady[=${EpicSpiritStaff}]}) {
		/useitem "${EpicSpiritStaff}"
		/delay 10
	} else /if (!${Me.Buff[Roar of the Lion].ID} && !${Me.Buff[Dissident Roar].ID} && ${Me.CurrentMana}>${Spell[${DichoSpell}].Mana} && (!${Me.Casting.ID}) && ${Me.SpellReady[${DichoSpell}]} && ${UseRoar}) {
		/call SpellQueue "${DichoSpell}" ${assistid}
		/delay 10
	}
/return
|----------------------------------------------------------------------------
|- SUB: Combatdps
|---------------------------------------------------------------------------- 
Sub Combatdps
	/doevents
	/if ( ${Target.CurrentHPs}<=${AutoAssistAt} && ${Target.ID}==${autotargetid} && ${Target.Distance}<=${AssistRange} && ${Ok2Assist}) {
		|- Pet Attack
		/if ((!${Me.Pet.Combat} || ${Pet.Target.ID}!=${autotargetid}) && ${Me.Pet.ID} && ${Target.Type.Equal[NPC]} && ${Target.ID} && ${Target.CurrentHPs}<=${AutoAssistAt} && ${UsePet}) {
			/pet attack 
			/pet swarm
		}
        /if (!${Me.Moving} && !${Me.Casting.ID} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight} && ${Target.ID} && ${Cast.Status.Equal[I]}) {
            /if ( ${DoDot} && (${Me.SpellReady[${DotSpell}]}) && (!${Target.Buff[${DotSpell}].ID}) && ${Me.CurrentMana}>${Spell[${DotSpell}].Mana}) {
                /call SpellQueue "${DotSpell}" ${autotargetid}
            }
            /if ( ${Target.Type.NotEqual[Corpse]} && ${Me.SpellReady[${NukeSpell}]} && ${Me.CurrentMana}>${Spell[${NukeSpell}].Mana} && ${Me.CurrentMana}>${Manatonuke} && ${Target.LineOfSight} ) {
                /call SpellQueue "${NukeSpell}" ${autotargetid}
            }
        }
        
		|- DPS
|-		/if (${Me.PctMana}>=${Manatonuke} && ${ReadyToCast}==0) {
|-			/if (${Cast.Status.Equal[I]} && ${DoDot} && (${Me.XTarget}>=${BurnMobCount} || (${Target.Named} && ${BurnNamed}) || ${BurnAlways} || ${burnnow}) && (${Me.SpellReady[${DoTSpell1}]}) && (!${Target.Buff[${DoTSpell1}].ID})) {
|-				/call SpellQueue "${DoTSpell1}" ${autotargetid}
|-			} else /if (${Cast.Status.Equal[I]} && ${DoDot} && (${Me.XTarget}>=${BurnMobCount} || (${Target.Named} && ${BurnNamed}) || ${BurnAlways} || ${burnnow}) && (${Me.SpellReady[${DoTSpell2}]}) && (!${Target.Buff[${DoTSpell2}].ID})) {
|-				/call SpellQueue "${DoTSpell2}" ${autotargetid}
|-			} else /if (${UseSwarmpet} && ${Cast.Status.Equal[I]} && ${Me.SpellReady[${Spell[${SwarmPet}].RankName}]} && ${Me.CurrentMana}>${Spell[${SwarmPet}].Mana} && !${Me.Moving} && !${Target.Type.Equal[Corpse]} && ${Target.LineOfSight}) {
|-				/call SpellQueue "${Spell[${SwarmPet}].RankName}" ${autotargetid}
|-			} else /if (${Me.SpellReady[${PetGrowl}]} && ${Me.Level}<85 && !${Me.Buff[${PetGrowl}].ID} && !${Me.Song[${PetGrowl}].ID}) {
|-				/call CastSpell "${PetGrowl}" ${autotargetid} cbt
|-			}
|-		}
|-		/varset groupbufftimer 1m
	}		
/return
|----------------------------------------------------------------------------
|- SUB: RezCheck
|---------------------------------------------------------------------------- 
Sub RezCheck
    /declare RezID int local
	
	/if (${reztimer}==0 && ${Alert[3].Size}>0) /alert clear 3
	|- Will not rez in Guild Hall - Plane of Knowledge -- looking for other corpses. Will add already rezzed corpses to alert group #3
    |- NOTE: May need to add the else /if from IHCCLR that looks for the ${Me} corpse.
    /if (${Spawn[pccorpse noalert 3 group radius 100 zradius 50].ID} && (${Select[${Zone.ID},345,202]}==0)) {
        /varset RezID ${Spawn[pccorpse noalert 3 group radius 100 zradius 50].ID}
		/target id ${RezID}
		/delay 5 ${Target.ID}==${RezID}
		/if (${Target.Distance}>25) /corpse
		/delay 5 ${Target.Distance}<25
        
        |- Are we in combat?
        /if (${Me.CombatState.Equal[COMBAT]}) {
            |- If we're in combat, see if we've allowed in combat rez. If so, rez, if not, do nothing.
            /if (${UseBattleRez} && ${Me.AltAbilityReady[${BattleRezSpell}]}) {
                /call AANow ${Me.AltAbility[Call of the Wild].ID} ${RezID}
                /delay 4s !${Me.Casting.ID}
                /alert add 3 id ${RezID}
                /varset reztimer ${RetryRezDelay}s
            }
        } else {
            |- We're not in combat, let's cast our OOC rez if we have mana and it's in our book. If it's not ready, don't do anything.
            /if (${Me.Level}>=100) {
                /call AANow ${Me.AltAbility[Rejuvenation of Spirit].ID} ${RezID}
                /delay 9s !${Me.Casting.ID}
                /alert add 3 id ${RezID}
                /varset reztimer ${RetryRezDelay}s 
             } else /if (${Me.Book[${OOCRezSpell}]} && ${Me.CurrentMana}>${Spell[${OOCRezSpell}].Mana}) {
                /call SpellQueue "${OOCRezSpell}" ${RezID}
                /alert add 3 id ${RezID}
                /varset reztimer ${RetryRezDelay}s
            }
        }
    } else /if (${Spawn[pccorpse ${Me} noalert 3 radius 100 zradius 50].ID} && (${Select[${Zone.ID},345,202]}==0)) {
        |- looking for my corpse -- looking for other corpses. Will add already rezzed corpses to alert group #3
        /varset RezID ${Spawn[pccorpse ${Me} noalert 3 radius 100 zradius 50].ID}
		/target id ${RezID}
		/delay 5 ${Target.ID}==${RezID}
		/if (${Target.Distance}>25) /corpse
		/delay 5 ${Target.Distance}<25
        
        |- Are we in combat?
        /if (${Me.CombatState.Equal[COMBAT]}) {
            |- If we're in combat, see if we've allowed in combat rez. If so, rez, if not, do nothing.
            /if (${UseBattleRez} && ${Me.AltAbilityReady[${BattleRezSpell}]}) {
                 /call AANow ${Me.AltAbility[Call of the Wild].ID} ${RezID}
                /delay 4s !${Me.Casting.ID}
                /alert add 3 id ${RezID}
                /varset reztimer ${RetryRezDelay}s
            }
        } else {
            |- We're not in combat, let's cast our OOC rez if we have mana and it's in our book. If it's not ready, don't do anything.
            /if (${Me.Level}>=100) {
                /call AANow ${Me.AltAbility[Rejuvenation of Spirit].ID} ${RezID}
                /delay 9s !${Me.Casting.ID}
                /alert add 3 id ${RezID}
                /varset reztimer ${RetryRezDelay}s 
             } else /if (${Me.Book[${OOCRezSpell}]} && ${Me.CurrentMana}>${Spell[${OOCRezSpell}].Mana}) {
                /call SpellQueue "${OOCRezSpell}" ${RezID}
                /alert add 3 id ${RezID}
                /varset reztimer ${RetryRezDelay}s
            }
        }
    }
/return
|----------------------------------------------------------------------------
|- SUB: BuffGroup
|---------------------------------------------------------------------------- 
Sub BuffGroup
	/declare bmember			int local 0
	/if (${groupbufftimer}==0) /varset groupbufftimer 10s
	/for bmember 1 to ${Group}
		/if (${Group.Member[${bmember}].Distance}<100 && !${Group.Member[${bmember}].OtherZone} && (!${Me.Casting.ID}) && ${DanNet.Peers.Find[${Group.Member[${bmember}].Name.Lower}]}) {
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Focus.ID" "tmpbuffid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${FocusSpell}].Stacks" "tmpstackcheck" "bool"
				/if (!${tmpbuffid} && ${tmpstackcheck} && ${Me.Book[${FocusSpell}]} && ${Me.CurrentMana}>${Spell[${FocusSpell}].Mana} && (!${Me.Casting.ID}) && !${Select[${Group.Member[${bmember}].Class.ShortName},CLR,SHM,NEC,ENC,WIZ,MAG]} && ${UseFocus}) {
					/call SpellQueue "${FocusSpell}" ${Group.Member[${bmember}].ID}
					/varset spellrememtimer 5s
					/delay 10
				}
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${RunSpeedBuff}].ID" "tmpbuffid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${RunSpeedBuff}].Stacks" "tmpstackcheck" "bool"
				/if (!${tmpbuffid} && ${tmpstackcheck} && ${Me.CurrentMana}>${Spell[${RunSpeedBuff}].Mana} && ${UseRunSpeed} && (!${Me.Casting.ID})) {
					/if (${Me.AltAbilityReady[Lupine Spirit]} && ${Me.AltAbility[Lupine Spirit].Rank}>=4) {
						/alt act ${Me.AltAbility[Lupine Spirit].ID}
						/delay 70
					} else /if (${Me.Book[${RunSpeedBuff}]}) {
						/call SpellQueue "${RunSpeedBuff}" ${Group.Member[${bmember}].ID}
						/varset spellrememtimer 5s
						/delay 10
					}					
				}
				/if (${Me.CurrentMana}>${Spell[${GrowthBuff}].Mana} && ${Group.Member[${bmember}].ID}==${assistid} && (!${Me.Casting.ID}) && ${Me.SpellReady[${GrowthBuff}]} && ${UseGrowthBuff}) {
					/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${GrowthBuff}].ID" "tmpbuffid" "int"
					/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${GrowthBuff}].Stacks" "tmpstackcheck" "bool"
					/if (!${tmpbuffid} && ${tmpstackcheck}) {
						/call SpellQueue "${GrowthBuff}" ${Group.Member[${bmember}].ID}
						/varset spellrememtimer 5s
						/delay 10
					}
				}
				/if (${Me.CurrentMana}>${Spell[${AllianceBuff}].Mana} && ${Group.Member[${bmember}].ID}==${assistid} && (!${Me.Casting.ID}) && ${Me.SpellReady[${AllianceBuff}]} && ${UseAllianceBuff}) {
					/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${AllianceBuff}].ID" "tmpbuffid" "int"
					/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${AllianceBuff}].Stacks" "tmpstackcheck" "bool"
					/if (!${tmpbuffid} && ${tmpstackcheck}) {
						/call SpellQueue "${AllianceBuff}" ${Group.Member[${bmember}].ID}
						/varset spellrememtimer 5s
						/delay 10
					}
				}
				/if (${Me.CurrentMana}>${Spell[${SlowProcBuff}].Mana} && ${Group.Member[${bmember}].ID}==${assistid} && (!${Me.Casting.ID}) && ${Me.SpellReady[${SlowProcBuff}]} && ${DoHeals}) {
					/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${SlowProcBuff}].ID" "tmpbuffid" "int"
					/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${SlowProcBuff}].Stacks" "tmpstackcheck" "bool"
					/if (!${tmpbuffid} && ${tmpstackcheck}) {
						/call SpellQueue "${SlowProcBuff}" ${Group.Member[${bmember}].ID}
						/varset spellrememtimer 5s
						/delay 10
					}
				}
		}
	/next bmember
	|- Delete variable's
	/if (${Defined[tmpbuffid]}) /deletevar tmpbuffid
	/if (${Defined[tmpstackcheck]}) /deletevar tmpstackcheck
	/if (${Group.MainAssist.ID} && ${Target.ID}!=${Group.MainAssist.ID}) {
		/target id ${Group.MainAssist.ID}
		/if (${ReTargetDelay}==0) /varset ReTargetDelay 1m
		/if (${autotargetid}) /varset autotargetid 0
	}
/return
|----------------------------------------------------------------------------
|- SUB: BuffCheck
|----------------------------------------------------------------------------
Sub BuffCheck
	/if (!${Spell[${Me.Aura[1]}].ID} && ${Me.AltAbilityReady[${ShamanAura}]}) {
		/alt act ${Me.AltAbility[${ShamanAura}].ID}
		/delay 5
	} else /if (${UsePet} && !${Me.Pet.ID} && ${Cast.Status.Equal[I]} && ${Me.Book[${PetSpell}]} && ${Me.CurrentMana}>${Spell[${PetSpell}].Mana}) {
		/call SpellQueue "${PetSpell}" ${Me.ID}
		/varset spellrememtimer 5s
	} else /if (!${Me.Buff[${FocusSpell}].ID} && !${Me.Focus.ID} && (!${Me.Casting.ID}) && ${Me.Book[${FocusSpell}]} && ${Me.CurrentMana}>${Spell[${FocusSpell}].Mana} && ${UseFocus}) {
		/call SpellQueue "${FocusSpell}" ${Me.ID}
		/varset spellrememtimer 5s
	} else /if (!${Me.Buff[${RunSpeedBuff}].ID} && (!${Me.Casting.ID}) && (${Spell[${RunSpeedBuff}].Stacks}) && ${Me.CurrentMana}>${Spell[${RunSpeedBuff}].Mana} && ${UseRunSpeed}) {
		/if (${Me.AltAbilityReady[Lupine Spirit]} && ${Me.AltAbility[Lupine Spirit].Rank}>=4) {
			/alt act ${Me.AltAbility[Lupine Spirit].ID}
			/delay 70
		} else /if (${Me.Book[${RunSpeedBuff}]}) {
			/call SpellQueue "${RunSpeedBuff}" ${Me.ID}
			/varset spellrememtimer 5s
		}
	} else /if (!${Me.Buff[${GroupHealProcBuff}].ID} && !${Me.Casting.ID} && ${Spell[${GroupHealProcBuff}].Stacks} && ${Me.Book[${GroupHealProcBuff}]} && ${Me.CurrentMana}>${Spell[${GroupHealProcBuff}].Mana}) {
		/call SpellQueue "${GroupHealProcBuff}" ${Me.ID}
		/varset spellrememtimer 5s
	} else /if (${Me.AltAbilityReady[Preincarnation]} && ${Me.AltAbility[Preincarnation].Rank}>=2 && !${Me.Buff[Preincarnation].ID}) {
		/alt act ${Me.AltAbility[Preincarnation].ID}
		/delay 15
	} else /if (!${Me.Buff[${PackSelfBuff}].ID} && !${Me.Casting.ID} && ${Spell[${PackSelfBuff}].Stacks} && ${Me.Book[${PackSelfBuff}]} && ${Me.CurrentMana}>${Spell[${PackSelfBuff}].Mana}) {
		/call SpellQueue "${PackSelfBuff}" ${Me.ID}
		/varset spellrememtimer 5s
	} else /if (!${Me.Buff[${SelfHealProcBuff}].ID} && !${Me.Casting.ID} && ${Spell[${SelfHealProcBuff}].Stacks} && ${Me.SpellReady[${SelfHealProcBuff}]} && ${Me.CurrentMana}>${Spell[${SelfHealProcBuff}].Mana}) {
		/call SpellQueue "${SelfHealProcBuff}" ${Me.ID}
		/varset spellrememtimer 5s
	} else /if (!${Me.Gem[${spellmisc}].Name.Equal[${miscspellremem}]} && ${spellrememtimer}==0 && ${miscspellremem.NotEqual[NULL]} && !${BringYourOwnSpells}) {
		/call LoadSpellGem "${miscspellremem}" ${spellmisc}
	}
|- else /if (${UsePet} && !${DoPetTank} && !${Me.Pet.Buff[${PetOffenseBuff}]} &&  ${Spell[${PetOffenseBuff}].StacksPet} && (!${Me.Casting.ID}) && ${Me.Book[${PetOffenseBuff}]} && ${Me.CurrentMana}>${Spell[${PetOffenseBuff}].Mana}) {
|-		/call SpellQueue "${PetOffenseBuff}" ${Me.ID}
|-		/varset spellrememtimer 5s
|-	} else /if (${Me.PctHPs}>70 && ${Me.PctMana}<80 && ${Me.AltAbilityReady[Consumption of Spirit]} && !${Me.Invis}) {
|-		/call AANow ${Me.AltAbility[Consumption of Spirit].ID}
|-	}
/return
|----------------------------------------------------------------------------
|- SUB: ConfigHeal
|---------------------------------------------------------------------------- 
Sub ConfigHeal
	/if (${Select[${Zone.ID},795,796]}==0 && !${Raid.Members}) {
		/if (${Me.XTarget}>2 || ${Me.XTarget[1].Named}) {
			/if (${TankHealPoint}!=95) {
				/varset TankHealPoint 95
				/varset GroupHealPoint 85
				/varset BigHealPoint 80
			}
		} else /if (${Me.XTarget[1].Level}>=${Me.Level}) {
			/if (${TankHealPoint}!=85) {
				/varset TankHealPoint 85
				/varset GroupHealPoint 80
				/varset BigHealPoint 70
			}
		} else /if (${Me.XTarget[1].Level}>=${Math.Calc[${Me.Level}-5]}) {
			/if (${TankHealPoint}!=80) {
				/varset TankHealPoint 80
				/varset GroupHealPoint 75
				/varset BigHealPoint 60
			}
		} else {
			/if (${TankHealPoint}!=70) {
				/varset TankHealPoint 70
				/varset GroupHealPoint 75
				/varset BigHealPoint 60
			}
		}
	} else /if (${TankHealPoint}!=${TBMHealPoint} && !${Raid.Members}) {
		/varset HealPoint ${TBMHealPoint}
		/varset TankHealPoint ${TBMHealPoint}
		/varcalc GroupHealPoint ${TBMHealPoint}-5
		/varcalc BigHealPoint ${TBMHealPoint}-10
	} else /if (${TankHealPoint}!=${RaidHealPoint} && ${Raid.Members}) {
		/varset HealPoint ${RaidHealPoint}
		/varset TankHealPoint ${RaidHealPoint}
		/varcalc GroupHealPoint ${RaidHealPoint}-5
		/varcalc BigHealPoint ${RaidHealPoint}-10
	}
/return
|----------------------------------------------------------------------------
|- SUB: TankChangeCheck
|---------------------------------------------------------------------------- 
Sub TankChangeCheck
	/if (${PetTank} && ${Group.Member[${assistname}].Pet.ID}) {
		/docommand /varset tempid ${Group.Member[${assistname}].Pet.ID}
		/if (${tempid}!=${assistid}) {
			/echo Tank ID Mismatch - Fixing it
			/varset assistid ${tempid}
		}
	} else /if (!${PetTank} && ${Group.Member[${assistname}].ID}) {
		/docommand /varset tempid ${Group.Member[${assistname}].ID}
		/if (${tempid}!=${assistid}) {
			/echo Tank ID Mismatch - Fixing it
			/varset assistid ${tempid}
		}
	}
	/if (!${Spawn[${assistid}].PctHPs}>=1) {
		/if (!${Bool[${oldtank}]}) /varset oldtank ${assistname}
		/if (!${Bool[${oldtankid}]}) /varset oldtankid ${assistid}
		/if (${Spawn[group notid ${Me.ID} radius 150].ID}) {
			/echo Tank Gone - Switching to Nearest Group Member Alive
			/varset assistname ${Spawn[group notid ${Me.ID} radius 150]}
			/varset assistid ${Spawn[group notid ${Me.ID} radius 150].ID}
			/if (${Spawn[${assistid}].Type.Equal[Pet]}) {
				/varset TnKCond .Pet.
			} else {
				/varset TnKCond .
			}
		} else {
			/echo Tank and Group Gone - Switching to Self Heal mode
			/varset assistname ${Me.Name}
			/varset assistid ${Me.ID}
			/varset TnKCond .
		}
	}
	/if (${Group.Member[${oldtank}].ID}) {
		/if (!${PetTank}) {
			/varset assistname ${oldtank}
			/varset assistid ${Group.Member[${oldtank}].ID}
			/echo Tank is Back - Switching him back to maintank
			/varset oldtank NULL
			/varset oldtankid NULL
		} else /if (${PetTank} && ${Group.Member[${oldtank}].Pet.ID}) {
			/varset assistname ${oldtank}
			/varset assistid ${Group.Member[${oldtank}].Pet.ID}
			/echo Tank is Back - Switching him back to maintank
			/varset oldtank NULL
			/varset oldtankid NULL
		}
		/if (${Spawn[${assistid}].Type.Equal[Pet]}) {
			/varset TnKCond .Pet.
		} else {
			/varset TnKCond .
		}
	}
	/if (${newtank}==1) {
		/docommand /varset assistid ${Target.ID}
		/varset newtank 0
		/if (${Spawn[${assistid}].Type.Equal[Pet]}) {
			/docommand /varset assistname ${Target.Master.Name}
			/echo Main Tank set to ${Target.Name}
			/varset TnKCond .Pet.
			/varset PetTank 1
		} else {
			/docommand /varset assistname ${Target.Name}
			/echo Main Tank set to ${assistname}
			/varset TnKCond .
			/varset PetTank 0
		}
	}
/return
  
|----------------------------------------------------------------------------
|- SUB: Symbol - HP Buff Single use
|----------------------------------------------------------------------------
Sub Event_Chat(string ChatType,string ChatSender,string ChatText)
	/if (${Spawn[${ChatSender.Right[-2].Left[-1]}].ID}) {
		/if (${Select[${ChatText},Cure,cure,CURE,RC,Radiant,GC]} && (${Spawn[${ChatSender.Right[-2].Left[-1]}].Distance}<200)) /call SingleCure ${Spawn[${ChatSender.Right[-2].Left[-1]}].ID}
	}
/return
|----------------------------------------------------------------------------
|- SUB: Event NotOnTarget - For dealing with too far away and cannot see messages
|----------------------------------------------------------------------------
Sub Event_NotOnTarget
	/if (${DoAutoEngage}) {
		/squelch /attack off
		/if (${DoAutoTarget}) /call FindTarget
		/delay 5
		/if (${Target.Distance}<${AssistRange}) /call EngageTarget
	}
	/doevents flush NotOnTarget
/return 
|----------------------------------------------------------------------------
|- SUB: Event_WornOff
|----------------------------------------------------------------------------
Sub Event_WornOff
	/doevents flush WornOff
/return 
|----------------------------------------------------------------------------
|- SUB: Event GroupChange
|----------------------------------------------------------------------------
Sub Event_GroupChange

/return
